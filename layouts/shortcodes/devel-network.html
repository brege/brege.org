{{ $nodesPath := .Get "nodesPath" }}
{{ $edgesPath := .Get "edgesPath" }}

<style>
  /* make sure the graph container is always 60% of the window height */
  #network {
    height: 60vh;
  }
</style>

<!-- Network graph container -->
<div id="network"></div>

<!-- Vis.js library -->
<script src="https://visjs.github.io/vis-network/standalone/umd/vis-network.min.js"></script>

<script>
  // define the node styles

  const nodeStylesPrime = {
    nodes: {
      color: {
        background: '#BBDEFB',  // Light Blue 100
        border: '#2196F3',  // Light Blue 500
        highlight: {
          background: '#64B5F6',  // Light Blue 300
          border: '#2196F3'  // Light Blue 500
        }
      },
      font: {
        color: '#0D47A1',  // Light Blue 900
        size: 30,
        align: 'center'
      },
      shape: 'box',
      shapeProperties: {
        borderRadius: 3,
      }
    }
  };

  const nodeStylesOrigin = {
    nodes: {
      color: {
        background: '#EEEEEE',  // Light Grey
        border: '#9E9E9E',  // Grey 500
        highlight: {
          background: '#BDBDBD',  // Grey 300
          border: '#9E9E9E'  // Grey 500
        }
      },
      font: {
        color: '#212121',  // Grey 900
        size: 30,
        align: 'center'
      },
      shape: 'box',
      shapeProperties: {
        borderRadius: 3,
      }
    }
  };


   // define the network options
  const options = {
    interaction: {
      hover: true,
      hoverConnectedEdges: true,
    },
    autoResize: true,
  }

  // Create a new network graph
  const container = document.getElementById('network');
  const network = new vis.Network(container, {}, options);
  let nodes = [];
  let edges = [];

  // Load the data and display the graph
  async function displayGraph() {
    const nodesResponse = await fetch('{{ $nodesPath }}');
    nodes = await nodesResponse.json();
    const edgesResponse = await fetch('{{ $edgesPath }}');
    edges = await edgesResponse.json();
    // Apply the node styles
    network.setOptions(nodeStylesOrigin);
    // Display the graph with the nodes and edges data
    network.setData({ nodes: nodes, edges: edges });
  }

  // Display the graph when the page loads
  window.addEventListener('load', displayGraph);
  // Listen whenever selected results change
  document.addEventListener('selectedResultsChanged', function (e) {
    // Get the selected results from the event
    const selectedResults = e.detail;
    // Filter the nodes and edges based on the selected results
    filterNodesAndEdges(selectedResults);
  });
  

  function filterNodesAndEdges(selectedResults) {
    // Print the selected results to the console
    console.log('selectedResults', selectedResults);
    // From the selected results nodes, determine the list of every edge that connect to that node
    const matchingEdges = edges.filter(edge => selectedResults.includes(edge.from) || selectedResults.includes(edge.to));
    // From the matching edges, determine the list of every node that is connected to the selected results nodes
    const matchingNodes = nodes.filter(node => matchingEdges.some(edge => edge.from === node.id || edge.to === node.id));
    // Display the graph with the matching nodes and edges, 
    network.setData({ nodes: matchingNodes, edges: matchingEdges });
    // Apply the node styles
    network.setOptions(nodeStylesOrigin);
    network.body.data.nodes.update(matchingNodes.map(node => {
      if (selectedResults.includes(node.id)) {
        return { id: node.id, color: nodeStylesPrime.nodes.color };
      } else {
        return { id: node.id };
      }
    }));


    // if the selected results is empty, display the graph with all the nodes and edges
    if (selectedResults.length === 0) {
      network.setData({ nodes: nodes, edges: edges });
      network.setOptions(nodeStylesOrigin);
    }
   }

</script> 
